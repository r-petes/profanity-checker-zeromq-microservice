'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const dictionary_1 = __importDefault(require("./data/dictionary"));
const util_1 = require("./util");
const console_1 = __importDefault(require("console"));
/**
 * Profanity class.
 */
class Profanity {
    /**
     * Profanity constructor.
     * @constructor
     * @param {string} inputStr - Input string to evaluate profanity.
     * @param {object} config - Profanity configurations.
     * @param {number} config.level - Level to replace placeHolder in profane words.
     * @param {boolean} config.saveOriginal - Define if the original input string will be saved.
     * @param {array} config.enabled - Define if the filter will be enabled.
     * @param {string} config.placeHolder - Character used to replace profane words.
     * @param {string} config.replaceRegex - Regular expression used to replace profane words with placeHolder.
     * @param {RegExp} config.separatorRegex - Regular expression used to split a string into words.
     * @param {Array} config.excludeWords - List of words to be ignored when filter profane words.
     * @param {Array} config.wordsList - List of words to be override the default dictionary of profane words.
     * @param {string} config.language - Language used to filter profane texts.
     */
    constructor(inputStr = '', config) {
        var _a, _b, _c;
        this.censuredPhrase = '';
        const configDefaults = {
            level: 1,
            saveOriginal: true,
            enabled: true,
            placeHolder: '*',
            replaceRegex: /[\wÀ-ž]/g,
            separatorRegex: /\w+|[^\w\s]|\s+/g,
            excludeWords: [],
            language: 'pt-br',
        };
        this.phrase = !inputStr || inputStr.length < 1 ? '' : inputStr;
        this.config = Object.assign(Object.assign({}, configDefaults), config);
        this.wordlist = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.wordsList) !== null && _b !== void 0 ? _b : util_1.getProperty(dictionary_1.default, (_c = this.config) === null || _c === void 0 ? void 0 : _c.language).words;
    }
    /**
     * Evaluate if string is profane.
     * @return Profanity instance
     * @private
     */
    scan() {
        var _a, _b, _c;
        if (this.phrase.length < 1) {
            this.censuredPhrase = this.phrase;
            return this;
        }
        const separatorRegex = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.separatorRegex) ? (_b = this.config) === null || _b === void 0 ? void 0 : _b.separatorRegex : '';
        this.censuredPhrase = (_c = this.normalizeText(this.phrase)
            .match(separatorRegex)) === null || _c === void 0 ? void 0 : _c.map((value) => {
            return this.isProfane(value) ? this.censureWord(value) : value;
        }).reduce((current, next) => current + next, '');
        return this;
    }
    /**
     * Censure a word with placeHolder characters.
     * @param {any} word - String to censure.
     * @public
     */
    censureWord(word) {
        var _a, _b;
        if (word === undefined) {
            console_1.default.error('Unexpected error: missing word');
            return;
        }
        return word.replace((_a = this.config) === null || _a === void 0 ? void 0 : _a.replaceRegex, (_b = this.config) === null || _b === void 0 ? void 0 : _b.placeHolder);
    }
    /**
     * Returns the string normalization from string sentence with diacritics.
     * @param str - Sentence to be normalized.
     * @return string normalized
     * @private
     */
    normalizeText(str) {
        return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }
    /**
     * Evaluate if string is profanity and return an edited version.
     * @param {string} str - Sentence to filter (if sent it will overlap inputStr in constructor).
     * @return edited version
     * @public
     */
    censor(str) {
        var _a, _b;
        this.originalText = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.saveOriginal) ? this.phrase : '';
        // if false return origianl sentence
        if (!((_b = this.config) === null || _b === void 0 ? void 0 : _b.enabled)) {
            return this.phrase;
        }
        if (str)
            this.phrase = str;
        this.scan();
        return this.censuredPhrase;
    }
    /**
     * Evaluate if a string is a profane language.
     * @param {string} value - String to evaluate for profanity.
     * @return true or false
     * @public
     */
    isProfane(value) {
        if (this.wordlist === undefined) {
            console_1.default.error('Unexpected error: wordlist is invalid.');
            return;
        }
        return this.wordlist.filter((word) => {
            var _a, _b;
            const regex = new RegExp(`\\b${word.replace(/(\W)/g, '\\$1')}\\b`, 'gi');
            return !((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.excludeWords) === null || _b === void 0 ? void 0 : _b.includes(word.toLowerCase())) && regex.test(value);
        }).length > 0
            ? true
            : false;
    }
    /**
     * Return original text if config.saveOrigial as true.
     * @return original version
     * @public
     */
    loadOriginal() {
        var _a;
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.saveOriginal) {
            return this.originalText;
        }
        return '';
    }
    /**
     * Add word(s) to wordlist filter.
     * @param {...string} words - Word(s) to add to wordlist.
     * @public
     */
    addWords(...words) {
        var _a;
        if (words.length === 0)
            console_1.default.error('Unexpected error: need at last one word');
        (_a = this.wordlist) === null || _a === void 0 ? void 0 : _a.push(...words);
        return this;
    }
    /**
     * Remove word(s) to wordlist filter.
     * @param {...string} words - Word(s) to be removed from wordlist.
     * @public
     */
    removeWords(...words) {
        var _a;
        if (words.length === 0)
            console_1.default.error('Unexpected error: need at last one word to remove');
        const regex = new RegExp(words.join('|'), 'i');
        this.wordlist = (_a = this.wordlist) === null || _a === void 0 ? void 0 : _a.filter((item) => {
            if (!regex.test(item))
                return item;
        });
        return this;
    }
}
module.exports = Profanity;
//# sourceMappingURL=index.js.map